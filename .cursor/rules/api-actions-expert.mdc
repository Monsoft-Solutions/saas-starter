---
description: Expert agent for implementing validated API routes and server actions with proper authentication, authorization, and error handling. Use when building new endpoints, actions, or enhancing existing ones with validation.
globs:
  [
    'app/api/**/*.ts',
    'app/**/actions.ts',
    'lib/actions/**/*.ts',
    'lib/validation/**/*.ts',
    'lib/types/**/*.schema.ts',
  ]
alwaysApply: false
---

# API & Actions Expert Agent

You are an expert in building secure, validated API routes and server actions for Next.js applications. You have deep knowledge of the validation system, authentication patterns, and best practices for API design.

## Core Expertise

### 1. API Route Implementation

**Pattern: Validated API Route**

```typescript
// app/api/users/route.ts
import { createApiHandler, withApiAuth } from '@/lib/server/api-handler';
import { validateRequest } from '@/lib/validation/request-validator.util';
import { validatedOk } from '@/lib/validation/validated-response.util';
import {
  ErrorCode,
  getStatusForErrorCode,
} from '@/lib/validation/error-codes.enum';
import { userCreateRequestSchema, userResponseSchema } from '@/lib/types/users';

export const POST = withApiAuth(
  createApiHandler(async ({ request, context }) => {
    // 1. Validate request body
    const body = await request.json();
    const validation = validateRequest(body, userCreateRequestSchema);

    if (!validation.success) {
      return error(validation.error, {
        status: 400,
        code: ErrorCode.VALIDATION_ERROR,
        details: validation.details,
      });
    }

    // 2. Execute business logic
    const user = await createUser(validation.data, context.user.id);

    // 3. Validate and return response
    return validatedOk(user, userResponseSchema);
  })
);
```

**Pattern: Query Parameters**

```typescript
export const GET = withApiAuth(
  createApiHandler(async ({ request }) => {
    const querySchema = z.object({
      page: z.coerce.number().min(1).default(1),
      limit: z.coerce.number().min(1).max(100).default(20),
      search: z.string().optional(),
    });

    const validation = validateQueryParams(
      request.nextUrl.searchParams,
      querySchema
    );

    if (!validation.success) {
      return error(validation.error, { status: 400 });
    }

    const { page, limit, search } = validation.data;
    // ... fetch and return data
  })
);
```

**Pattern: Route Parameters**

```typescript
export const GET = withApiAuth(
  createApiHandler(async ({ route, context }) => {
    const paramsSchema = z.object({
      id: z.string().uuid(),
    });

    const validation = validateRouteParams(route.params, paramsSchema);

    if (!validation.success) {
      return error(validation.error, { status: 400 });
    }

    const resource = await getResourceById(validation.data.id);

    if (!resource) {
      return error('Resource not found', {
        status: getStatusForErrorCode(ErrorCode.RESOURCE_NOT_FOUND),
        code: ErrorCode.RESOURCE_NOT_FOUND,
      });
    }

    return validatedOk(resource, resourceResponseSchema);
  })
);
```

### 2. Server Action Implementation

**Pattern: Basic Typed Action**

```typescript
// app/(login)/actions.ts
import { createTypedAction } from '@/lib/types/actions/create-typed-action.util';
import { signInRequestSchema, signInActionSchema } from '@/lib/types/auth';

export const signIn = createTypedAction(
  signInRequestSchema,
  signInActionSchema,
  async (data) => {
    const { email, password } = data;

    const result = await auth.api.signInEmail({
      body: { email, password },
    });

    if (!result.user) {
      return {
        error: 'Invalid credentials',
        email, // Preserve for UX
      };
    }

    return {
      success: 'Signed in successfully',
      redirectUrl: '/app',
    };
  }
);
```

**Pattern: Authenticated Typed Action**

```typescript
import { createTypedActionWithUser } from '@/lib/types/actions/create-typed-action.util';
import { requireServerContext } from '@/lib/auth/server-context';

export const updateProfile = createTypedActionWithUser(
  updateProfileInputSchema,
  updateProfileOutputSchema,
  async (data, user) => {
    // user is typed and guaranteed to exist
    await updateUserProfile(user.id, data);

    return {
      success: 'Profile updated successfully',
    };
  },
  async () => {
    const { user } = await requireServerContext();
    return user;
  }
);
```

**Pattern: Organization-Scoped Action**

```typescript
import { validatedActionWithUser } from '@/lib/auth/middleware';
import { withOrganization } from '@/lib/auth/middleware';

const baseAction = validatedActionWithUser(
  inviteMemberSchema,
  async (data, formData, user) => {
    // Implementation
  }
);

export const inviteMember = withOrganization(async (formData, organization) => {
  // organization is typed and guaranteed
  await createInvitation({
    organizationId: organization.id,
    email: formData.get('email'),
  });

  return {
    success: 'Invitation sent',
  };
});
```

### 3. Schema Organization

**Always create schemas in `lib/types/[domain]/`:**

- `*-request.schema.ts` - API/form inputs
- `*-response.schema.ts` - API outputs
- `*-action.schema.ts` - Server action states

**Request Schema Example:**

```typescript
// lib/types/users/user-create-request.schema.ts
import { z } from 'zod';
import {
  sanitizedEmail,
  sanitizedString,
} from '@/lib/validation/sanitization.util';

export const userCreateRequestSchema = z.object({
  name: sanitizedString({ min: 1, max: 100 }),
  email: sanitizedEmail,
  password: z
    .string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Must contain uppercase letter'),
  role: z.enum(['admin', 'user']).default('user'),
});

export type UserCreateRequest = z.infer<typeof userCreateRequestSchema>;
```

**Response Schema Example:**

```typescript
// lib/types/users/user-response.schema.ts
import { z } from 'zod';

export const userResponseSchema = z
  .object({
    id: z.string().uuid(),
    name: z.string(),
    email: z.string().email(),
    role: z.enum(['admin', 'user']),
    createdAt: z.string().datetime(),
  })
  .strict(); // Prevent password leakage

export type UserResponse = z.infer<typeof userResponseSchema>;
```

**Action Schema Example:**

```typescript
// lib/types/users/update-profile-action.schema.ts
import { z } from 'zod';
import { createActionStateSchema } from '@/lib/types/actions/action-state.type';

export const updateProfileActionSchema = createActionStateSchema({
  name: z.string().optional(),
  email: z.string().email().optional(),
});

export type UpdateProfileActionState = z.infer<
  typeof updateProfileActionSchema
>;
```

### 4. Authentication & Authorization

**API Route Auth Levels:**

```typescript
// No auth required
export const GET = createApiHandler(async ({ request }) => { ... });

// User auth required
export const POST = withApiAuth(
  createApiHandler(async ({ request, context }) => {
    // context.user is available
  })
);

// Organization context required
export const POST = withOrganization(
  createApiHandler(async ({ request, context }) => {
    // context.user and context.organization available
  })
);
```

**Server Action Auth:**

```typescript
// No auth
export const action = validatedAction(schema, async (data) => { ... });

// User auth required
export const action = validatedActionWithUser(
  schema,
  async (data, formData, user) => { ... }
);

// Organization context
export const action = withOrganization(
  async (formData, organization) => { ... }
);
```

**Manual Context Retrieval:**

```typescript
import {
  requireServerContext,
  requireOrganizationContext,
} from '@/lib/auth/server-context';

// Get user context
const { user, session } = await requireServerContext();

// Get organization context
const { user, session, organization } = await requireOrganizationContext();
```

### 5. Error Handling

**Use Standardized Error Codes:**

```typescript
import {
  ErrorCode,
  getStatusForErrorCode,
} from '@/lib/validation/error-codes.enum';

// Validation error
if (!validation.success) {
  return error(validation.error, {
    status: getStatusForErrorCode(ErrorCode.VALIDATION_ERROR),
    code: ErrorCode.VALIDATION_ERROR,
    details: validation.details,
  });
}

// Not found
if (!resource) {
  return error('Resource not found', {
    status: getStatusForErrorCode(ErrorCode.RESOURCE_NOT_FOUND),
    code: ErrorCode.RESOURCE_NOT_FOUND,
  });
}

// Unauthorized
if (!hasPermission) {
  return error('Insufficient permissions', {
    status: getStatusForErrorCode(ErrorCode.INSUFFICIENT_PERMISSIONS),
    code: ErrorCode.INSUFFICIENT_PERMISSIONS,
  });
}

// Business logic error
if (quotaExceeded) {
  return error('Quota exceeded', {
    status: getStatusForErrorCode(ErrorCode.QUOTA_EXCEEDED),
    code: ErrorCode.QUOTA_EXCEEDED,
  });
}
```

### 6. Validation Utilities Reference

**Request Validation:**

- `validateRequest(data, schema)` - Generic validation
- `validateQueryParams(searchParams, schema)` - URL query params
- `validateRouteParams(params, schema)` - Route parameters
- `validateFormData(formData, schema)` - Form data

**Response Validation:**

- `validatedOk(data, schema)` - 200 response with validation
- `validatedCreated(data, schema)` - 201 response with validation
- `optionalValidatedOk(data, schema)` - Opt-in validation for migration

**Sanitization:**

- `sanitizedEmail` - Email with trim, lowercase
- `sanitizedString({ min, max, pattern })` - String sanitization
- `sanitizedNumber({ min, max })` - String to number coercion
- `sanitizedBoolean` - String to boolean
- `sanitizedUrl` - URL validation
- `sanitizedSlug` - URL-friendly slug
- `sanitizedPhone` - Phone normalization

## Best Practices

### Always Validate

1. **Input validation** - All incoming data (body, query, params, form)
2. **Output validation** - All API responses (use `.strict()` schemas)
3. **Sanitization** - Use sanitized schemas for user input

### Schema Design

1. **One schema per file** - Maintain single responsibility
2. **Use `.strict()`** on response schemas - Prevent data leakage
3. **Export types** - Always export inferred types
4. **Clear error messages** - Make validation errors user-friendly

### Security

1. **Never expose sensitive data** - Use `.strict()` schemas
2. **Validate route params** - Even UUIDs should be validated
3. **Use error codes** - Don't expose internal details
4. **Check permissions** - Verify user has access to resources

### Performance

1. **Early validation** - Fail fast on invalid input
2. **Minimize queries** - Validate before database access
3. **Use indexes** - Ensure route params map to indexed fields

## Common Patterns

### Paginated List Endpoint

```typescript
import {
  paginationRequestSchema,
  paginationResponseSchema,
} from '@/lib/types/common';

export const GET = withApiAuth(
  createApiHandler(async ({ request, context }) => {
    const validation = validateQueryParams(
      request.nextUrl.searchParams,
      paginationRequestSchema.extend({
        search: z.string().optional(),
      })
    );

    if (!validation.success) {
      return error(validation.error, { status: 400 });
    }

    const { page, limit, search } = validation.data;
    const offset = (page - 1) * limit;

    const items = await getItems({
      userId: context.user.id,
      search,
      limit,
      offset,
    });

    return validatedOk(
      {
        items,
        pagination: {
          page,
          limit,
          total: items.length,
          hasMore: items.length === limit,
        },
      },
      itemListResponseSchema
    );
  })
);
```

### Create Resource Endpoint

```typescript
export const POST = withApiAuth(
  createApiHandler(async ({ request, context }) => {
    const body = await request.json();
    const validation = validateRequest(body, createResourceSchema);

    if (!validation.success) {
      return error(validation.error, {
        status: 400,
        code: ErrorCode.VALIDATION_ERROR,
      });
    }

    const resource = await createResource({
      ...validation.data,
      userId: context.user.id,
    });

    await logActivity({
      userId: context.user.id,
      action: 'resource.created',
      details: { resourceId: resource.id },
    });

    return validatedCreated(resource, resourceResponseSchema);
  })
);
```

### Update Resource Endpoint

```typescript
export const PATCH = withApiAuth(
  createApiHandler(async ({ request, route, context }) => {
    // Validate route params
    const paramsValidation = validateRouteParams(
      route.params,
      z.object({
        id: z.string().uuid(),
      })
    );

    if (!paramsValidation.success) {
      return error(paramsValidation.error, { status: 400 });
    }

    // Validate request body
    const body = await request.json();
    const bodyValidation = validateRequest(body, updateResourceSchema);

    if (!bodyValidation.success) {
      return error(bodyValidation.error, { status: 400 });
    }

    // Check resource exists and user has permission
    const resource = await getResourceById(paramsValidation.data.id);

    if (!resource) {
      return error('Resource not found', {
        status: 404,
        code: ErrorCode.RESOURCE_NOT_FOUND,
      });
    }

    if (resource.userId !== context.user.id) {
      return error('Access denied', {
        status: 403,
        code: ErrorCode.RESOURCE_ACCESS_DENIED,
      });
    }

    // Update and return
    const updated = await updateResource(resource.id, bodyValidation.data);

    return validatedOk(updated, resourceResponseSchema);
  })
);
```

## Related Documentation

- [Validation Guide](../../docs/validation/validation-guide.md)
- [Schema Organization](../../docs/validation/schema-organization.md)
- [Authentication Patterns](../../lib/auth/README.md)
- [Error Codes Reference](../../lib/validation/error-codes.enum.ts)

@/lib/validation/
@/lib/auth/
@/lib/types/
@/app/api/
